# Particle emitter optimization notes

## Поточні гарячі точки CPU
- **`advanceParticleEmitterState`** створює та оновлює об'єкти частинок на CPU, а потім перезаписує ціликом буфер вершин у `writeEmitterBuffer`. Це означає, що при `capacity` у сотні елементів ми на кожному кадрі формуємо 6 вершин * `VERTEX_COMPONENTS` значень для кожної частинки.
- Для неактивних слотів емісії ми теж записуємо вершини (з нульовим розміром), щоб підтримувати фіксований розмір буфера. Це гарантує відсутність переприв'язок VBO, але коштом додаткових копій даних.

## Потенційні оптимізації на CPU
- Перейти від масиву об'єктів `ParticleEmitterParticleState` до декількох `Float32Array`, що зберігають позиції/швидкості/час життя. Це усуне тиск на GC та відкриє можливість використовувати `gl.bufferSubData` для часткових оновлень.
- Тримати окремий буфер для «неактивних» вершин і копіювати його лише коли `capacity` змінюється. Поточна реалізація перераховує дані для кожного кадру, навіть якщо конфігурація не змінювалась.
- Для емісій з великою кількістю частинок розглянути динамічний перехід на інстансинг (`ANGLE_instanced_arrays` / WebGL2 `drawArraysInstanced`). Тоді CPU формуватиме один чотирикутник і масив атрибутів-інстансів.

## Винесення симуляції на GPU
- Оновлення положень/швидкостей можна перенести у вершинний/обчислювальний шейдер через підхід з подвійною буферизацією (transform feedback у WebGL2 або framebuffer ping-pong у WebGL1). CPU тоді оновлюватиме лише параметри емісії, а позиції зберігатимуться в текстурах/SSBO.
- Якщо обрати текстурний підхід, для кожної частинки тримати у RGBA текстурі `position.xy`, `velocity.xy`, `age`, `lifetime`. Вершинний шейдер вибиратиме дані за `gl_InstanceID` (WebGL2) або через `vertexId` після декодування UV.
- Для випадків, коли форма частинки складна (градієнти), шейдер може обчислювати альфу на льоту за віком, позбавляючи CPU від `applyParticleAlpha` та серії `Float32Array` копій.

## Моменти, на які слід звернути увагу
- Будь-який GPU-підхід потребує синхронізації життєвого циклу частинки. Варто зберігати «seed» для випадкових величин у буфері, щоб шейдери могли відтворювати однакові значення без CPU.
- Якщо залишаємо оновлення на CPU, важливо обмежувати `state.spawnAccumulator` місткістю, щоб уникнути накопичення «боргу» по спавну, котрий неможливо реалізувати через брак слотів.
- При формуванні геометрії потрібно використовувати нормалізований розмір (`effectiveSize`), щоб частинки нульового розміру не колапсували у лінію.

## Подальші кроки
1. Впровадити структуру даних на базі `Float32Array` для стану частинок.
2. Перейти на оновлення буферів через `gl.bufferSubData`/інстансинг.
3. Прототипувати ping-pong текстурну симуляцію і виміряти виграш на великих емісіях (10k+ частинок).
