# Оптимізація емісії частинок

## Поточні гарячі точки CPU
- **`advanceParticleEmitterState`** формує та оновлює об'єкти частинок на CPU, після чого повністю перезаписує буфер вершин через `writeEmitterBuffer`. За місткості у сотні частинок це означає 6 вершин × `VERTEX_COMPONENTS` значень для кожної частинки на кожному кадрі.
- Навіть неактивні слоти емісії заповнюються нульовим геометричним відбитком, щоб зберігати сталий розмір VBO. Це знімає потребу переприв'язувати буфер, але додає копіювання даних.

## Ідеї оптимізації на CPU
- Замінити масив об'єктів `ParticleEmitterParticleState` набором `Float32Array`, які зберігатимуть позиції, швидкості та час життя. Це зменшить тиск на GC і дозволить використовувати `gl.bufferSubData` для часткових оновлень.
- Тримати окремий буфер для «порожніх» вершин і копіювати його лише при зміні `capacity`. Нинішня реалізація генерує дані щоразу, навіть без змін конфігурації.
- Для емісій з великим числом частинок розглянути перехід на інстансинг (`ANGLE_instanced_arrays` / WebGL2 `drawArraysInstanced`). CPU формуватиме один квадрат і масив атрибутів-інстансів.

## Симуляція на GPU
- Положення та швидкості можна перенести до вершинного або обчислювального шейдера, використовуючи трансформаційний фідбек (WebGL2) або ping-pong текстури (WebGL1). У такому випадку CPU оновлюватиме лише параметри емісії.
- Зберігайте у текстурі `RGBA` такі значення: `position.xy`, `velocity.xy`, `age`, `lifetime`. Шейдер вибиратиме дані за `gl_InstanceID` або декодуватиме UV.
- Для складних форм частинок шейдер може обчислювати альфу за віком, позбавляючи CPU викликів `applyParticleAlpha` та масових копій масивів.

## На що зважати
- GPU-підхід потребує збереження «seed» для випадкових величин, щоб шейдери могли відтворити послідовність без участі CPU.
- Якщо симуляція лишається на CPU, обмежуйте `state.spawnAccumulator` місткістю, аби не накопичувати неможливий до спавну борг.
- При формуванні геометрії варто використовувати нормалізований розмір (`effectiveSize`), інакше частинки нульового розміру колапсують у лінію.

## Наступні кроки
1. Переписати зберігання стану частинок на `Float32Array`.
2. Перейти на оновлення буферів через `gl.bufferSubData` або інстансинг.
3. Спроектувати ping-pong симуляцію й заміряти виграш на великих емісіях (10k+ частинок).
